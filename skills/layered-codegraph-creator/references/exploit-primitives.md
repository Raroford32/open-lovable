# Exploit Primitives from a Codegraph (capability-first)

Goal: turn “complete coverage” into attack hypotheses that are *testable*.

## Reality gates (to avoid dead-end reasoning)
- **Permissionless only**: do not assume stolen keys, admin collusion, or off-chain coercion. If a primitive needs privilege, the privilege must be gained via a publicly reachable state transition.
- **No labels**: never collapse a primitive into a category name. Keep it as capability + broken assumption + preconditions + measurable effect.
- **Proof discipline**: until you have a fork/sim test with a measurable delta, every primitive is a hypothesis (not “safe”, not “fixed”).

Additional discipline (for “beyond-known” discovery):
- Prefer starting from protocol-specific invariants (L14) and generating primitives as attempts to falsify an invariant, not as pattern matching.
- Prefer scenario composition (combine multiple edges/levers) over single-mechanism explanations.

Anti-primary-vuln posture:
- Treat one-step primitives as warm-up only.
- Require at least one composed primitive per top-ranked target state X (state shaping + settlement/extraction).

## Output format (one primitive card)
Write each primitive as:
- **Capability**: “A normal user can force the system to accept state X.”
- **Target asset and custody**: which asset/custody location(s) or claims are expected to change; what “profit” means in measurable terms.
- **Broken assumption**: the implicit belief the code relies on.
- **On-chain preconditions**: concrete state + caller/context + order/timing needed.
- **Measurable effect**: what increases/decreases (protocol asset ↓, attacker claim ↑, attacker debt ↓).
- **Exit measurement**: how the delta is measured/quoted on fork (and what exit constraints are assumed).
- **Evidence pointers**: the minimal node/edge chain that supports the hypothesis.
- **Smallest falsifier**: the simplest fork/sim test that would disprove it.

Never collapse to labels. Use capability language only.

## Prioritization rubric (min cost, max delta)
For each entrypoint/primitive, score quickly (don’t overthink):
- **Delta bound**: max loss limited by reserves/TVL/caps/withdraw liquidity.
- **Reachability**: preconditions likely on live chain (not “rare edge state” unless you can force it cheaply).
- **Complexity**: smallest falsifier fits in a short fork/sim test (few calls, few dependencies).
- **Competition**: if MEV can steal it, note whether the attacker still wins permissionlessly.

Prefer: high delta bound + high reachability + low complexity.

Capital-efficiency bias (matches target class):
- Prefer primitives where the measurable delta is large relative to `capitalIn` at risk.
- If the first proof requires high `capitalIn`, treat it as a stepping stone: add a “capital minimization plan” mutation and keep iterating.

Autopilot rule: if the user didn’t specify what to focus on, pick the highest-scoring primitive yourself and proceed. Ask only for missing hard requirements (RPC/archive access, missing build artifacts), not for strategic selection.

High-signal primitives usually involve at least one of:
- custody vs ledger mismatch (credit/debit without real balance movement)
- unit conversion/rounding drift that accumulates over repetitions
- check-then-invalidated windows inside a tx or across tx boundaries
- inconsistent “value views” across modules (A accepts a number B doesn’t enforce)
- external dependency trust edges that can be influenced by a normal user (directly or via state shaping)
- control-plane capture routes (a normal user changes future behavior control, then monetizes later)
- approval-surface routes (user approvals become latent custody that can be converted into transfers)
- ordering-sensitive routes (same-block positioning or multi-tx setup/action splits)
- profit-positive cycles (a multi-step loop yields net positive output per iteration)

## Procedure: generate primitives per entrypoint
1. Start from `L5_external_surface.md` entrypoints; rank by value impact using `L11_value.md`.
2. For each entrypoint:
   - List user-controlled levers (inputs, caller type, batching/order, timing, token behavior).
   - List checks/guards (auth, pause, limits, freshness, solvency).
   - Identify custody movements and ledger updates (see `asset-custody-mapping.md`).
   - Identify unit conversions and rounding points (see `numeric-semantics.md`).
3. Mutate one lever against one assumption to produce a capability statement.
4. Attach a measurable effect and a loss bound (pool reserves, caps, TVL).

Alternative (often higher signal): start from invariants
1. Start from L14 invariants; write each negation as a target state X.
2. Use scenario synthesis to compose a plausible permissionless route to X (`references/scenario-synthesis.md`).
3. Convert that route into a primitive card and then into the smallest falsifier.

## Common “state X” targets (write them as states, not labels)
- “Ledger credits exceed real custody increase.”
- “Recorded debt decreases without paying the real debt asset.”
- “A check is passed, then invalidated later in the same tx, but the system doesn’t re-check.”
- “Internal accounting diverges from token reality at a custodian address.”
- “A conversion uses a manipulable reference (price/index/rate) that the system accepts.”

## Self-evaluation loop (force iteration)
After each primitive attempt (even if disproved), record:
- **What killed it**: the exact check, assumption, or unreachable state that blocked it.
- **What new lever you learned**: a discovered edge state, token behavior, or call ordering window.
- **Smallest falsifier next**: the one observation that collapses the biggest unknown.
- **Mutated primitive**: same capability with a new lever, or same lever against a different assumption.

If the primitive set collapses into “known one-step hypotheses,” treat it as premature convergence:
- return to invariant negations and scenario synthesis
- force at least one fusion attempt (combine state shaping from one route with extraction from another)

## Safety constraint
Prove feasibility only in a fork/sim. Avoid producing real-world draining instructions; focus on invariant violation + measurable delta.
